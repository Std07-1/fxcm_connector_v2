# Агрегація тикових даних у OHLCV для FXCM-конектора: механіки, аномалії та «реальний» volume на закритті бару

## Контекст і визначення «реального» volume у FXCM

У FX/CFD (зокрема XAUUSD) **трейдовий обсяг не є універсально доступним** так, як на біржових ринках, бо spot-FX є OTC. У більшості роздрібних платформ «volume» на свічках — це **tick volume** (лічильник змін ціни за період), тобто проксі активності, а не кількість контрактів/лотів, проторгованих на централізованій біржі. FXCM прямо визначає tick volume як кількість «ticks (або змін ціни)» за період графіка. citeturn2search0

Водночас FXCM має окреме поняття **Real Volume / Transactions**, яке описується як «реальний обсяг live-трейдів» і «сума індивідуальних транзакцій» клієнтів FXCM за період. Це **інший клас даних**, відмінний від tick volume, і він не тотожний стандартному «volume» з котирувань. citeturn2search6turn2search8  
Окремо FXCM Pro пропонує **volume data** як продукт (з переліком інструментів, включно з XAUUSD) з оновленням у JSON на 1-хв інтервалах — це теж **спеціалізоване джерело**, не автоматично присутнє в будь-якому тиковому фіді. citeturn2search7

У вашій системі під “реальним Volume” практично мається на увазі **канонічний volume, який повертає FXCM історичний сервіс барів (get_history / PriceHistory)** і який збігається з тим, що показує FXCM у своїх бар-чартах; він, найімовірніше, є tick-volume у сенсі FXCM, але важливо, що це **узгоджений “truth” усередині екосистеми FXCM**. Саме тому v2-політика еволюціонувала до: *tick-agg дає лише preview, а complete=true бари з правильним Volume беруться з history.* fileciteturn0file0

## Еволюція tick→OHLCV у v1 та v2: що змінилося принципово

### Базова проблема, яка керує еволюцією

Тиковий потік дає **ціну й час**, але **не гарантує “історичний” Volume** як у FXCM bar-history. Якщо просто вважати `volume = tick_count` або, гірше, закривати бар “close=open” при тиші, ви отримуєте:

- невідтворюваність обсягу (його значення залежить від пропусків тиков, мережевих джиттерів і дублювань),
- потенційні роз’їзди `open` через різні режими визначення open у FXCM history (детальніше нижче),
- неконтрольовані аномалії на межах сесій, under/overcount у “тонких” хвилинах,
- неконсистентність між UI (живий бар) і SMC (final бари).

Це прямо відображено у v2.3: **закриті бари з tick-agg перестали публікуватись назовні**, а після внутрішнього закриття tick-agg стрім **форсує FXCM history poll**, щоб швидко опублікувати `complete=true` свічку з «реальним» Volume. fileciteturn0file0

### Ключові віхи v2 та їхній сенс для правильного закриття бару

У v2.2 оформлено контрактність і правила для downstream (UDS/SMC): дедуп по `(symbol, tf, open_time)`, трактування `complete=false`, розділення `tick_ts` vs `snap_ts`. Це важливо, бо без контрактного поділу preview/final неможливо “чесно” жити з тиковою агрегацією. fileciteturn0file0

У v2.3 з’явилися три критичні елементи:

- **кламп майбутніх `tick_ts`** (якщо тик приходить “з майбутнього” >5с), щоб `clock-flush` міг закрити бари вчасно та не виникав стан “only_live_bars_no_complete”;  
- **heartbeat context для tick_agg** (queue depth, skew tick_ts, лічильники клампів, last_complete_close_ms) як діагностика закриття барів;  
- **політика volume**: preview volume рахується як tick volume (1.0 за тик), а `complete=true` береться з history; плюс додано **калібрування** `volume ≈ tick_count * k` для preview, де `k` оцінюється на парах `(history_volume, tick_count)` з однаковим `open_time`. fileciteturn0file0  

У v2.4 VolumeCalibrator зроблено адаптивним: порівняння способів оцінки `k` (median vs L2) за MAPE і публікація `predicted_volume` та `err_pct` у heartbeat. Це вже не «красивість», а інженерна умова: **якщо preview volume існує, то він має бути керовано наближений до history**, інакше UI/аналітика вводяться в оману. fileciteturn0file0

У v2.5–v2.6 з’являються здорова дисципліна “final з history” і масштабування:

- `complete=true` старших TF (`5m/15m/1h/4h`) формується як `history_agg` виключно з базового `1m` history;  
- додається MTF cross-check з прямим FXCM history для `1h/4h` з WARN при розбіжності понад поріг.  
Це показує загальний тренд: **final-істина повинна бути відтворювана й контрольована**, а не “як випало з live”. fileciteturn0file0

### Чому open ціни у tick-agg має бути “carryover” (інакше завжди буде дріфт)

ForexConnect `get_history` має параметр `candle_open_price_mode`, і в прикладі документації для Python він має дефолт **`PREVIOUS_CLOSE`**, тобто open свічки історично може визначатися як попередній close (а не як перший тик нової хвилини). citeturn1search1

Саме тому в конекторі окремо зафіксовано “Gapless Open Carryover (TV-like)” у tick-agg: при старті нового bucket `open` береться з `prev_close`, а high/low включають carryover-open і перший тик ціни. fileciteturn0file0  
Це не “косметика”: без цього ви не зійдетесь з FXCM history по open навіть на ідеальному тиковому фіді.

## Типові аномалії тикових даних і як вони ламають close/volume

Тикові ряди — **неоднорідні**: тики приходять із нерівномірною частотою, можуть бути дублікати, out-of-order, time-skew, а також “дірки” через мережу або паузи маркету. Системи high-frequency аналізу давно визнають, що такі артефакти напряму впливають на якість похідних величин (волатильність, агреговані бари тощо), тому потрібні механізми очищення/канонізації. citeturn6search0turn6search7

Нижче — практичний перелік аномалій, які найбільш критичні саме для **коректного закриття бару** і **volume**, з прив’язкою до ваших v2-рішень.

### Таблиця аномалій і механік захисту

| Аномалія | Симптом у stream | Як ламає бар | Мінімальна детекція | Робоча стратегія |
|---|---|---|---|---|
| `tick_ts` у майбутньому | tick-agg “не може закрити” бари, clock-flush не спрацьовує | бар “висить” як live, `complete=true` не з’являється | `tick_ts > now + δ` | clamp `tick_ts` до `now`, інкремент метрики й heartbeat skew fileciteturn0file0 |
| Out-of-order ticks | пізній тик з меншим timestamp | може “перемотати” high/low або навіть close (якщо реалізація наївна) | `tick_ts <= last_tick_ts` | **не дозволяти** late tick змінювати уже закритий bucket; або тримати малий reorder-buffer з жорстким TTL |
| Дублікати тика | однакові bid/ask/time приходять повторно | volume (tick_count) завищується; high/low можуть “флікати” | hash/ключ тика, коротка LRU | dedup у короткому вікні (наприклад 1–2s) перед агрегацією |
| Тиша біля boundary | перший тик наступного бару приходить із затримкою | бар **закривається пізніше**, close відповідає останньому тику до boundary, але публікація delayed | `now - last_tick_ts > T` | clock-flush: закривати бар на boundary + tolerance, а final перевіряти через history |
| Gap через market closed | довга дірка без тиков | якщо “імпутувати” бари тихо, можна приховати реальні market gaps | календар + `is_trading_time` | класифікація gap expected_closed vs unexpected; expected залишати як gap або робити synthetic з прапором |
| “Поточний незакритий бар” у history | FXCM history повертає bar із close_time у майбутньому | дублює/псує gate, створює шум, фальшиві close | `close_time > now` | відкидати незакриті history бари; логувати rate-limited DEBUG fileciteturn0file0 |

## Ілюстрації: як інконсистентні тики впливають на бар-закриття та volume

Нижче — синтетичні графіки, які показують дві класичні проблеми: *закриття бару сигналізується першим тиком наступного бару* та *tick_count як volume не збігається з канонічним “FXCM candle Volume”, тому потрібна калібровка/історичне підтвердження.*

![Синтетичний приклад: тики, пропуски та out-of-order впливають на момент закриття бару](sandbox:/mnt/data/tick_bar_closure_inconsistencies.png)

Цей патерн (“закриття попереднього бару стає відомим, коли прийшов перший тик наступного”) є типовим для event-driven бар-будування з тикового стріму: бар не може підтвердити своє завершення раніше, ніж побачить факт переходу у новий bucket, якщо у вас немає timer-based flush. У практичних фреймворках це також описується як правило: **bar closure сигналізується тиками наступного бару**, тому без clock-flush ви завжди матимете latency-залежність від першого тика наступної хвилини. citeturn1search3turn1search4

![Калібрування preview-обсягу: tick_count → наближення до history Volume](sandbox:/mnt/data/volume_calibration_tickcount_vs_history.png)

FXCM визначає tick volume як кількість тиков/змін ціни за період — це корелює з активністю, але не є “біржовим” обсягом. citeturn2search0  
Саме тому в конекторі v2.3+ прийнято: preview показує tick-based volume, але **final `complete=true` бари виходять з history з “реальним” Volume**, а preview лише калібрується під history через коефіцієнт `k`. fileciteturn0file0

## Як визначати “реальний” close і volume бару: методи та компроміси

### Метод агрегації тільки з тиков

Це класичні time bars: ви групуєте тики по `[open_time, close_time]`, берете:

- `open`: або перший тик у bucket, або carryover `prev_close` (краще для узгодження з FXCM history, бо `PREVIOUS_CLOSE` є дефолтом у get_history) citeturn1search1turn0file0  
- `high/low`: максимум/мінімум серед тиков у bucket (з включенням carryover-open, якщо застосовується),
- `close`: останній тик перед `close_time`,
- `volume`: tick_count або сума tick-size (якщо він у вас є; у quote-stream часто нема).

Проблема: **close і volume стають функцією якості тикового фіду**, а не канонічними FXCM-значеннями. Для UI це нормально (preview), для SMC — ризик.

### Метод “гібрид”: tick preview + history final

Це фактично те, до чого прийшов ваш v2.3:

1. tick-agg тримає live бар (`complete=false`) і стрімить його часто в UI;
2. при переході у наступний bucket tick-agg внутрішньо “закриває” бар, але **не публікує його як final**;
3. одразу запускається **форсований history poll** (мінімальна латентність, без очікування publish interval), який повертає закритий bar із кращим Volume та узгодженим open-mode;
4. у Redis/UDS публікується `complete=true` саме з history, а preview залишається UI-only. fileciteturn0file0

Цей підхід максимально узгоджується з тим, як влаштований ForexConnect Price History API: він маршрутизує запити між Quotes Manager і ForexConnect та використовує кешування, але вимагає активного сесійного з’єднання і має стандартний набір TF. citeturn2search10turn0search0turn0search14

### Метод “history-first”: тільки get_history для барів

Це простіше, але ви втрачаєте живу свічку (або отримуєте її з затримкою) і залежите від лімітів історичного API (наприклад, застереження про обмеження кількості барів за виклик є типовим для FXCM-сумісних клієнтів). citeturn2search11turn1search1

### Метод “справжній trade volume”: Real Volume / Pro Volume

Якщо вам потрібен саме **trade volume**, а не tick volume, то в екосистемі FXCM є:

- Real Volume / Transactions індикатори (сума транзакцій клієнтів FXCM) citeturn2search6turn2search8  
- FXCM Pro volume dataset з оновленням щохвилини citeturn2search7  

Це вже інша інтеграція (інший feed/продукт), і вона не випливає автоматично з quote ticks чи get_history. Для більшості задач “канонічний volume з FXCM bar-history” достатній як внутрішній truth, але важливо не плутати його з біржовим.

### Порівняльна таблиця підходів

| Підхід | Основне джерело | Latency | Узгодженість close | Узгодженість volume | Ризик “брехні” | Рекомендовано для |
|---|---|---:|---:|---:|---|---|
| Pure tick time-bars | quote ticks | низька | середня (залежить від тиков) | низька/середня (tick_count) | високий для final | UI preview, діагностика, microstructure |
| Hybrid (tick preview + history final) | ticks + get_history | низька для preview / середня для final | висока (final) | висока відносно FXCM-істини (final) | контрольований | **SMC/UDS final + UI live** |
| Pure history polling | get_history | середня | висока | висока (FXCM candle volume) | низький | SSOT/архів, простий runtime |
| Real Volume / Pro Volume stitching | Pro volume feed | середня | залежить від ціни | висока як trade volume FXCM | контрольований | Advanced volume analytics (окремий продукт) |

## Пороги, толеранси та відмінність “ринкового gap” від “помилки даних”

Ключова інженерна вимога: **нормалізація не має замітати реальні market events** (weekend open gap, break gap, новини), але має ловити системні збої (пропущені бари в trading time, out-of-order після канонізації тощо).

У вашому стеку це вже формалізовано через календарно-обізнані правила і деградації:

- для `1d` введено класифікацію missing day-bucket як `expected_closed`, якщо в цьому day-bucket календарно не було торгівлі (weekend/holiday/weekly close), і `unexpected`, якщо торгівля була — тоді hard reject. fileciteturn0file0  
- окремими змінами фіксувався UTC-оверрайд календаря для металів, щоб DST не породжував фальшиві “missing bars in trading time”, а також уточнювались точні межі daily break/open (наприклад, зміщення open на 23:01, якщо FXCM history не містить бару рівно на 23:00). fileciteturn0file0  

Для tick-агрегації практично застосовні такі **пороги**, які не “ховають” реальність:

- **Time closure tolerance**: дозволяти `clock-flush` закрити бар, якщо `now >= close_boundary + grace_ms`, але *final* приймати лише після history або після явної деградації `final_missing_history_confirmation`. Це зменшує latency, але не підміняє truth.
- **Price discrepancy thresholds (tick vs history)**:  
  - `|close_tick - close_hist| <= max(point_size, spread_p50)` → OK;  
  - вище — `degraded` + метрика + snapshot для RCA.  
  (point_size/spread агрегуються з OfferTable/статусу.)
- **Volume discrepancy thresholds**:  
  - для preview калібратор тримає MAPE по останніх N семплах; якщо `MAPE > θ` (наприклад 25–40%) або `samples < N_min`, UI має показувати volume як “preview/approx”, а SMC не повинен це споживати. У v2.4 вже є `err_pct` у heartbeat, що дає готовий сигнал для такого гейту. fileciteturn0file0

## Рекомендована “залізобетонна” стратегія для v1/v2: алгоритм, метрики, тести, reconcile

### Канонічна політика даних: строга межа preview vs final

Практика v2.3+ є правильною і її варто зробити “невідкочуваною рейкою”:

- `complete=false` (preview): з tick-agg, дозволені часті апдейти, volume=tick_count або tick_count*k, event_ts відсутній.
- `complete=true` (final): **лише history / history_agg**, з `event_ts == close_time` (або чітко визначеним event-time), і забороною змішування `synthetic=true`/`complete=false` у final. У v3-лінії це вже підсилюється “no mixing rail” і канонізатором перед publish. fileciteturn0file0

### Псевдокод “гібридного” агрегатора з валідацією закриття

```python
class TickToOhlcvEngine:
    """
    Побудова preview OHLCV з тиков + швидка валідація/фіксація final через FXCM history.
    Правило: final = тільки history; ticks = тільки preview.
    """

    def on_tick(self, symbol: str, bid: float, ask: float, tick_ts_ms: int) -> None:
        tick_ts_ms = self._clamp_future_tick_ts(tick_ts_ms)  # rail з v2.3 fileciteturn0file0
        mid = (bid + ask) / 2.0

        bucket_open = floor_to_tf(tick_ts_ms, tf_ms=self.tf_ms)

        if self.cur is None:
            self._start_bucket(bucket_open, mid, tick_ts_ms)
            self._publish_preview()
            return

        if bucket_open == self.cur.open_time:
            self.cur.update(mid, tick_ts_ms)          # high/low/close, tick_count
            self._publish_preview_rate_limited()
            return

        # Перехід у новий bucket: preview-бар попереднього bucket стає "кандидатом на final"
        prev_bucket = self.cur
        self._close_bucket_locally(prev_bucket)       # локально закрили (але не publish final)

        self._start_bucket(bucket_open, mid, tick_ts_ms)  # open = prev_close (carryover) fileciteturn0file0
        self._publish_preview()

        # Форсуємо history poll для prev_bucket.open_time (мінімум 2-3 бари lookback)
        self.history_verify_queue.push(
            HistoryVerifyJob(symbol=symbol, tf=self.tf, open_time=prev_bucket.open_time)
        )

    def history_verify_worker(self) -> None:
        job = self.history_verify_queue.pop()
        bars = fxcm_get_history(symbol=job.symbol, tf=job.tf, lookback_bars=3)

        final_bar = pick_bar_by_open_time(bars, job.open_time)
        if final_bar is None:
            self.metrics.final_missing_history += 1
            self.status.degraded.append("final_missing_history_confirmation")
            return

        # Ключова рейка: final має бути complete=true і з канонічним часом
        final_bar.complete = True
        final_bar.event_ts = final_bar.close_time   # як SSOT-final fileciteturn0file0

        # Дедуп/канонізація перед publish (sort, keep-last, time snapping, hard reject структурних порушень)
        final_bar = canonicalize_final_bar(final_bar)  # v3-рейки fileciteturn0file0

        publish_final(final_bar)

        # Калібрування preview volume: k = f(history_volume / tick_count)
        self.volume_calibrator.add_sample(
            tick_count=self.last_tick_count_for_open_time(job.open_time),
            history_volume=final_bar.volume
        )  # v2.3–v2.4 VolumeCalibrator fileciteturn0file0
```

Це саме той “скелет”, який забезпечує: **живий графік без брехні для SMC** і **final-істину, сумісну з FXCM**.

### Метрики та тести, які потрібні саме для правильного close/volume

У v2 уже закладено частину observability (tick_agg context, volume_calibration, VCAL viewer). fileciteturn0file0  
Щоб довести якість до “залізобетону”, метрики мають прямо відповідати failure-модам:

- `tick_out_of_order_total{symbol}` — скільки тиков прийшло `<= last_tick_ts`;
- `tick_future_clamp_total{symbol}` — скільки разів застосовано clamp майбутніх tиков; fileciteturn0file0  
- `ohlcv_preview_updates_total{symbol,tf}` і `ohlcv_final_bars_total{symbol,tf}`;
- `ohlcv_final_missing_history_total{symbol,tf}` — скільки закриттів не підтверджено history;
- `ohlcv_close_diff_abs{symbol,tf}` / `ohlcv_high_diff_abs` / `ohlcv_low_diff_abs` (tick vs history) — для RCA;
- `ohlcv_volume_ratio{symbol,tf}` (history_volume / tick_count) і `ohlcv_volume_mape{symbol,tf}` — з калібратора (v2.4 уже рахує err%). fileciteturn0file0  

Тести, які реально ловлять регресії:

- **bucket boundary + carryover-open**: на вході тики, на виході open має дорівнювати prev_close, інакше history завжди “не зійдеться”. citeturn1search1turn0file0  
- **future tick clamp**: якщо тик прийшов у майбутньому, бар все одно має закриватися clock-flush’ем. fileciteturn0file0  
- **final-only gate**: tick-agg не повинен публікувати `complete=true` назовні взагалі; final приходить лише з history. fileciteturn0file0  
- **history “current not closed bar” filter**: бар із `close_time > now` не має потрапити в final publish. fileciteturn0file0  
- **volume calibration stability**: при 0 семплів — k не застосовується; при ≥N — MAPE < θ.

### Stitch live↔history: як робити узгоджено і без приховування подій

Рекомендована модель reconcile для вашого кейсу (SMC потребує стабільних `complete=true`):

1. tick-agg завжди будує preview, але **ніколи не стає truth**.
2. final бар для того ж `open_time` приходить з history:
   - якщо він вкладається в price/volume толеранси — “нормальний” шлях;
   - якщо відхилення значне — final все одно перемагає (бо SSOT), але ви:
     - інкрементите `ohlcv_history_discrepancy_total`,
     - додаєте `degraded` у статус,
     - (опційно) тригерите `republish_tail` для короткого хвоста, щоб downstream гарантовано підхопив виправлення.  
   У вашій v3-лінії ідея републішу хвоста/repair вже формалізована як окремі операції, що є правильною експлуатаційною практикою для “виправив → перепоширив”. fileciteturn0file0

3. gap-и класифікуються календарем; expected_closed не лікуються, unexpected лікуються (tail_guard / backfill) з бюджетами й loud-статусом. fileciteturn0file0

Це дає потрібну вам властивість: **нормалізація не “затирає” реальні market gaps**, але системні збої стають видимими через метрики/статус і підлягають детермінованому ремонту.

---

**Головний висновок для вашої цілі (“accurate bar closure з реальним volume”)**: на тиковому фіді **немає надійного способу “відновити” FXCM candle Volume** без опори на FXCM history або окремий volume-продукт. Тому інженерно правильний шлях — саме той, який уже закріплено у v2.3+: **tick-agg = preview**, **history = final**, плюс **калібрування preview volume**, **carryover-open** для узгодження з `PREVIOUS_CLOSE`, і **рейки/гейти** (канонізатор, hard reject структурних порушень, календарна класифікація gap-ів). fileciteturn0file0turn1search1turn2search0turn2search10